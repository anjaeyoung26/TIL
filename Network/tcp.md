# Transmission Control Protocol

TCP는 [OSI 7계층](./osi-7-layer.md) 중 4계층인 [전송 계층](./osi-7-layer.md/#4계층---전송-계층)에서 사용하는 프로토콜이다. TCP는 데이터의 흐름 제어와 혼잡 제어를 수행하며, 연결 지향형으로 신뢰성있는 데이터의 전송을 보장하지만 UDP 보다 속도가 느리다. 우선 TCP의 특징에 대해 알아보자.

&nbsp;
## 특징

### 흐름 제어

TCP는 신뢰성 있는 프로토콜이다. 데이터를 전송할 때 마다 각 데이터에 **Sequence Number**라는 고유 번호를 부여하여, 수신 측에서는 중복된 데이터는 폐기하고, 알맞지 않은 순서로 수신되는 경우 순서대로 재구성할 수 있다. 또한 수신 측은 "문제없이 데이터를 수신했음"을 송신 측에게 알리기 위해 수신한 데이터의 Sequence Number 값에 1을 더한 **Ack Number**를 보낸다. 송신 측은 데이터를 전송하고 일정 시간이 지나도 수신 측에서 Ack Number를 보내지 않는다면 재전송을 하거나 연결이 끊어졌다고 판단한다. 이러한 TCP의 **흐름 제어** 기능을 통해 신뢰성 있는 데이터의 전송이 이루어질 수 있다.

### 혼잡 제어

TCP는 연결 초기에 송수신 측이 많은 양의 데이터를 주고 받을 준비가 되어있더라도 데이터의 송출량을 낮게 잡는다. 그리고 데이터의 교환이 이루어지면서 송수신 측을 확인하여 데이터의 송출량을 조금씩 늘린다. 이러한 과정을 거쳐가면서 현재 네트워크에서 가장 적합한 데이터의 송출량을 설정한다. TCP의 혼잡 제어 방식에는 AIMD와 Slow Start가 있다.

### 연결 지향

TCP는 연결 지향 프로토콜로, 물리적으로 전용 회선이 연결되어 있는 것처럼 **가상 회선을 설정**하고 1:1로 통신한다. 가상 회선 방식은 패킷을 보낸 순서와 도착하는 순서가 동일하며, 각 패킷에는 가상 회선을 식별하는 번호가 포함되어 있다. 패킷을 모두 전송하고 나면 가상 회선을 식별하는 번호를 통해 연결을 종료해야 한다. 이때 가상 회선을 연결하고 종료하는 과정을 Handshaking 라고 한다. 가상 회선을 연결하는 과정을 **3-Way Handshake** 라고 하며, 연결을 해제하는 과정을 **4-Way Handshake** 라고 한다.

### 따라서...

TCP는 송수신 측이 단일 경로 연결이 설정되어 1:1, 즉 유니캐스트 방식으로 통신한다. 그리고 데이터의 교환이 이루어질 때, 흐름 제어와 혼잡 제어를 수행하므로 UDP에 비해 속도가 느리다. 따라서 데이터의 전달에 대한 보장을 하지만 전달에 따른 지연에는 취약하므로 실시간 서비스에는 통상 UDP를 사용한다. TCP는 파일 전송과 같이 연속성보다 신뢰성이 더 중요한 서비스에 사용된다.

&nbsp;
## 3-Way Handshake

TCP 에서 데이터를 전송하기 위해 **연결을 성립**하는 과정을 3-Way Handshake 라고 한다. 이는 양 측이 데이터를 전송하고 수신할 준비가 되었다는 것을 보장하고, 실제로 데이터를 전송하기 전 송신 측에서 수신 측에게 데이터를 수신할 수 있는지 물어보고, 수신 측은 응답을 보내서 연결을 수립한다. 이제 3-Way Handshake가 어떻게 이루어지는지 그림으로 알아보자.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/171999714-377e89bf-b58c-4aba-901d-f6e9b7ea2bd7.png" width="600">
</p>

네트워크를 연결하기 위한 Handshake가 3-Way인 이유가 무엇일까? 이는 네트워크 연결을 위해 패킷을 3번 교환해야 하기 때문이다. 위 그림은 클라이언트에서 서버와 연결하기 위한 3-Way Handshake 과정을 나타낸다. 각 과정을 하나씩 살펴보자.

1. 클라이언트에서 서버에게 SYN 패킷을 전송한다. SYN 패킷에는 1000 값을 가지는 Sequence Number를 갖는다. 클라이언트는 SYN 패킷을 전송한 뒤 서버가 응답하기를 기다린다.

2. 서버는 클라이언트로부터 SYN 패킷을 수신하고 클라이언트에게 응답하기 위해 ACK 패킷을 전송한다. 이때 Ack Number는 수신한 SYN 패킷의 Sequence Number에서 1을 더한 1001의 값을 갖는다. 이는 SYN 패킷에 대한 응답임을 나타내기 위해 ACK 패킷에 포함시켜 응답한다.

3. 클라이언트는 서버로부터 받은 ACK 패킷의 Ack Number를 확인하고, 1번에서 보낸 SYN 패킷의 응답임을 확인한다. 비로소 클라이언트와 서버의 연결이 성립된다.


&nbsp;
## 4-Way Handshake

TCP 에서 연결되어 있는 **세션을 종료**하는 과정을 4-Way Handshake 라고 한다. 기존에 논리적으로 연결되어 있는 가상 회선을 해제하고 양 측의 연결을 위해 사용되었던 리소스를 정리한다. 4-Way Handshake는 3-Way Handshake와 달리 네 번의 패킷 교환이 이루어진다. 이제 4-Way Handshake가 어떻게 이루어지는지 그림으로 알아보자.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/172000729-ee491f49-4448-4951-b841-b5bc7754273f.png" width="600">
</p>

위 그림은 클라이언트에서 서버와 연결을 해제하기 위한 4-Way Handshake 과정을 나타낸다. 3-way Handshake와 비슷하지만 서버와 클라이언트 모두 FIN 패킷을 전송하는 것을 볼 수 있다. 각 과정을 하나씩 살펴보자.

1. 클라이언트에서 서버에게 FIN 패킷을 전송한다. FIN 패킷에는 5000 값을 가지는 Sequence Number를 갖는다. 클라이언트는 FIN 패킷을 전송한 뒤 서버가 응답하기를 기다린다.

2. 서버는 클라이언트로부터 FIN 패킷을 수신하고 클라이언트에게 응답하기 위해 ACK 패킷을 전송한다. 이때 Ack Number는 수신한 SYN 패킷의 Sequence Number에서 1을 더한 5001의 값을 갖는다. 이는 FIN 패킷에 대한 응답임을 나타내기 위해 ACK 패킷에 포함시켜 응답한다.

3. 서버는 연결을 종료하기 위해 클라이언트에게 FIN 패킷을 전송한다. 만약 서버가 FIN 패킷보다 이전에 전송한 패킷이 라우팅 지연, 패킷 유실로 인한 재전송 등의 이유로 FIN 패킷보다 늦게 전송할 수 있다. 이러한 현상에 대비하여, 클라이언트는 서버로부터 FIN 패킷을 수신해도 바로 연결을 해제하지 않고 일정 시간동안 세션을 유지시킨다.

4. 클라이언트는 서버로부터 FIN 패킷을 수신하고 일정 시간이 지난 뒤에 ACK 패킷을 전송한다. 2번 과정과 마찬가지로 수신한 SYN 패킷의 Sequence Number에서 1을 더한 6002의 값을 갖는 Ack Number를 포함시킨다. 서버는 클라이언트로부터 FIN/ACK 패킷을 수신하여 세션을 종료한다.