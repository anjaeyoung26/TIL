## 클래스와 구조체 중에서 선택하기

클래스와 구조체 모두 앱에서 데이터를 저장하고 동작을 모델링하는 데 좋은 선택이지만, 둘의 유사성으로 인해 둘 중 하나를 선택하기 어려울 수 있다. 공식 문서 [Choosing Between Structures and Classes](https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes)는 앱에서 새 데이터 타입을 추가할 때 클래스와 구조체 중 적절히 선택하기 위해 몇 가지 권장 사항을 가이드한다.

&nbsp;
### 1. 기본적으로 구조체를 선택

Swift의 구조체는 다른 프로그래밍 언어의 클래스와 같은 기능이 포함되어 있다. 구조체는 저장 프로퍼티, 연산 프로퍼티 및 메서드가 포함될 수 있으며 프로토콜을 채택할 수 있다. Swift의 표준 라이브러리 *Foundation*도 마찬가지로 `Int`, `String`, `Array` 등 많은 타입에 대해 구조체를 사용하고 있다. 기본적으로 구조체를 선택하는 이유 중 하나는 구조체가 값 타입이기 때문이다.

- 구조체에 대한 로컬 변경사항을 의도적으로 전달하지 않는 한 앱의 나머지 부분이 표시되지 않는 흐름의 일부이다. 예를 들어, 함수의 매개변수로 전달된 구조체의 인스턴스가 있을 때 함수 내에서 인스턴스의 값이 변경돼도 의도적으로 전달하지 않는 한 원본 변수의 값은 유지된다. 

- 값 타입은 메모리의 스택 영역을 사용함으로써 클래스와 같은 참조 타입이 메모리의 힙 영역을 사용하는 것보다 성능 상의 이점이 있다. 또한 멀티 스레드 환경에서 동시성 문제가 발생하지 않아 안전하게 사용할 수 있다. 자세한 내용은 [값 타입과 참조 타입](./call-by-value-reference.md)에서 살펴볼 수 있다.

- 다형성을 위해 클래스의 상속을 활용하는 것도, Swift에서는 프로토콜과 구조체의 조합으로 얼마든지 대체할 수 있다. 이는 상속 매커니즘을 Swift의 프로토콜로 대체할 수 있을 뿐만 아니라, 프로토콜과 *Extension*과 *Generic*을 함께 사용하여 더욱 다양하게 활용할 수 있다.

&nbsp;
### 2. Cocoa 프레임워크나 Objective-C 런타임이 필요할 때 클래스 사용

`UIKit`과 같이 Swift가 탄생하기 전에 만들어진 프레임워크는 모두 클래스를 사용하고 있다. 데이터를 모델링할 때 `UIKit`을 서브 클래싱하기 위해서는 클래스로 구현하여 상속을 받아야 한다. 또한 KVO와 같은 Objective-C 런타임의 매커니즘을 사용하기 위해서는 클래스를 사용해야 한다.

&nbsp;
### 3. 데이터의 변경을 공유해야할 때 클래스 사용

앱에서 클래스 인스턴스를 공유할 때, 해당 인스턴스에 대한 변경사항이 그 인스턴스를 참조하는 모든 곳에서 변경된다. 이러한 동일성의 종류를 가진 인스턴스가 필요하다면 클래스를 사용하는 것이 적절하다. 만약 공유할 데이터를 구조체로 구현했을 경우 발생하는 문제점은 Observer 패턴에서 확인할 수 있다.

```swift
struct Observable<T> {
  typealias Listener = (T) -> Void
  var listener: Listener?

  var value: T {
    didSet {
      listener?(value)
    }
  }

  init(_ value: T) {
    self.value = value
  }

  mutating func bind(listener: Listener?) {
    self.listener = listener
  }
}
```

`Observable`은 제너릭 타입의 값이 변경될 때마다 `Listener`에게 알린다. 언뜻 보면 문제가 없지만 `Observable`을 구조체로 구현하면서 값이 변경될 때 복사와 재할당이 일어난다. 이는 `mutating`이 일어날 때 인스턴스가 변하는게 아닌, 새로운 인스턴스를 자기 자신에게 할당하는 방식으로 동작한다. 따라서 `Observable`의 모든 인스턴스가 일관된 상태를 유지하지 않아서 `Listener`들은 일관성없는 값을 전달받게 된다. 이렇게 데이터의 변경을 공유하기를 원한다면 클래스를 사용해야 한다. 

> 하지만 클래스 인스턴스를 앱 전체에서 공유하면 [Race Condition](../OS/process-synchronization.md/#race-condition)과 같은 논리적 에러가 발생할 가능성이 높기 때문에 주의 깊게 다뤄야 한다.

&nbsp;
### 4. 모델의 상속이나 공유를 위해 구조체 + 프로토콜 사용

기본적으로 구조체는 상속을 지원하지 않지만 프로토콜을 채택해서 클래스의 상속과 같은 계층 구조를 만들 수 있다. 클래스를 통해 상속 구조를 만들면 클래스 간의 상속만 가능하기 때문에 범위가 제한되지만, 프로토콜은 클래스, 구조체, 열거형 모두 채택할 수 있다. 따라서 상속 관계를 처음부터 구축하는 경우 프로토콜 상속을 선호한다. 데이터 모델링을 할 때, 먼저 프로토콜 상속을 통해 데이터 타입의 계층 구조를 설계하고 구조체가 해당 프로토콜을 채택하도록 구현한다.