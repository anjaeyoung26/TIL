## MVVM

앞서 [*MVC*](./mvc.md)와 [*MVP*](./mvp.md) 패턴들은 컨트롤러, 프레젠터와 같은 중재 역할을 하는 구성 요소가 Massive하게 되는 문제가 있다. *MVC*에서 컨트롤러는 사용자의 상호 작용 이벤트와 관련된 사용자 인터페이스 로직과 필요한 데이터를 모델에게 요청하거나 모델의 데이터를 업데이트하는 비즈니스 로직을 모두 수행한다. *MVVM*은 뷰 모델이라는 새로운 구성 요소를 추가해서 컨트롤러가 가지고 있는 비즈니스 로직을 수행하게 한다. 따라서 각 구성 요소의 역할이 명확해져서 단위 테스트와 유지보수가 원활해질 수 있다. 또한 뷰와 뷰 모델은 1:N 관계를 가질 수 있으며, 이는 뷰 모델의 재사용이 가능함을 의미한다.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183080381-e237e5db-355e-4339-b6f4-4cdb9eabd389.png" width="450">
</p>

여기서 뷰가 뷰 모델을 소유하고 있으며, 뷰 모델은 모델을 소유하고 있다. 따라서 의존 관계는 뷰 -> 뷰 모델 -> 모델의 방향이다. 이러한 의존 관계의 방향을 일관성있게 유지하기 위해서 반대 방향에 있는 구성 요소의 존재를 몰라야 한다. 예를 들어, 뷰 모델의 상태가 변경된 것을 뷰에게 알리지 않고 뷰가 뷰 모델의 상태가 변경됨을 스스로 알아채야 한다. 이를 위해 *MVVM*은 *데이터 바인딩*이 함께 사용된다. 아래는 *데이터 바인딩*을 사용한 *MVVM*의 동작 과정이다.

1. 뷰에서 사용자의 입력을 받는다.
2. 뷰는 뷰 모델에게 사용자의 입력을 전달한다.
3. 뷰 모델은 뷰에게 전달받은 사용자의 입력에 따라 모델에게 데이터를 요청한다.
4. 모델은 요청받은 데이터를 뷰 모델에게 전달한다.
5. 뷰 모델은 모델에게 전달받은 데이터를 화면에 표시하기 적절한 형태로 가공하여 저장한다.
6. 뷰는 데이터 바인딩을 통해 뷰 모델의 상태가 변경됨을 알아차리고 UI를 업데이트한다.

여기서 *데이터 바인딩*은 6번 과정을 나타낸다. 또한 2번 과정에서 뷰는 *커맨더 패턴*을 사용하여 뷰 모델에게 사용자의 입력을 전달한다. *커맨더 패턴*이란, 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다. [출처 - 위키백과](https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%A7%A8%EB%93%9C_%ED%8C%A8%ED%84%B4)

&nbsp;
## 데이터 바인딩?

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183228318-5629ddee-a53e-4827-9c22-b644b7d0d342.png" width="450">
</p>

우선 데이터 바인딩이란, 제공자와 소비자로부터 데이터 원본을 결합시켜서 동기화하는 기법이다. *MVVM*에서 *데이터 바인딩*은 뷰가 뷰 모델의 상태가 변경됨을 스스로 알아채기 위해서 사용되는 개념이다. 뷰와 뷰 모델이 각자 소유하고 있는 데이터소스를 동기화시키기 위해 데이터 스트림을 연결한다. 만약 뷰 모델이 소유하고 있는 데이터소스의 값이 변경될 때, 데이터 스트림을 통해 뷰가 소유하고 있는 데이터소스도 갱신된다. *MVVM*에서 제공자(*Binding Source*)은 뷰 모델이고, 소비자(*Binding Target*)는 뷰이다. 또한 *데이터 바인딩*은 데이터 흐름의 방향에 따라 두 가지 종류가 있다.

&nbsp;
### 단방향 바인딩

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183228667-09bf3441-9e1c-45e0-9de5-bdcaa86aeae0.png" width="450">
</p>

*단방향 바인딩*은 소스 프로퍼티의 값이 변경될 경우 타겟 프로퍼티의 값이 자동으로 업데이트된다. 하지만 반대로 타겟 프로퍼티의 값이 변경될 경우 소스 프로퍼티에게 전달되지 않는다. 즉 데이터의 흐름이 하나의 방향만 존재한다. 이러한 *단방향 바인딩*은 바인드되는 컨트롤, 즉 *Dependency Property*가 읽기 전용인 경우에 적합하다. 예를 들어, 주식의 현재가를 차트로 나타내는 화면에서 타겟 프로퍼티는 소스 프로퍼티로부터 바인드된 가격을 차트로 나타내기만 하면 된다. *단방향 바인딩*은 타겟 프로퍼티를 모니터링하지 않아도 되는 경우 불필요한 리소스의 낭비를 방지할 수 있다.

&nbsp;
### 양방향 바인딩

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183229729-a65bc967-9a6a-431c-b4f3-0d819079aef9.png" width="450">
</p>

*양방향 바인딩*은 소스 프로퍼티 또는 타겟 프로퍼티의 값이 변경되면 다른 항목이 자동으로 업데이트된다. 이러한 *양방향 바인딩*은 읽기 전용이 아닌 읽기와 쓰기가 가능한 경우에 적합하다. 예를 들어 회원가입 화면에서 이메일을 입력하는 텍스트 필드의 내용이나 약관 동의 체크박스의 체크 여부 등은 사용자가 편집할 수 있는 컨트롤이므로 *앙방향 바인딩*이 적합하다. *단방향 바인딩*과 비교해서 두 방향의 데이터 흐름이 존재하므로 리소스를 추가적으로 사용한다.