## 반응형 프로그래밍

2년 전 iOS 공부를 시작할 때부터 [*RxSwift*](https://github.com/ReactiveX/RxSwift)는 많은 회사에서 우대 사항으로 뽑는 프레임워크 중 하나였다. 그만큼 현업에서 도입하고 있는 회사들이 많다는 의미이다. 나 또한 iOS 개발자로 취업하기 위해 다짜고짜 *RxSwift*를 공부했지만 정작 반응형 프로그래밍, *ReactiveX*, *RxSwift*를 사용해야 하는 이유, *RxSwift*의 대체제를 자신있게 설명할 수 없었다. 그래서 반응형 프로그래밍 부터 차근차근 알아보고자 한다. 먼저 ***반응형 프로그래밍***의 두 가지 정의를 찾았다.

1. 데이터 스트림과 그 변화에 대한 선언적 프로그래밍 패러다임이다.
2. 비동기적인 데이터 스트림을 이용한 프로그래밍 기법이다.

&nbsp;
## 데이터 스트림

'데이터 스트림'이란 **시간 순으로 발생하는 이벤트의 나열**을 의미한다. 이벤트의 '나열'이라고 해서 단순히 배열 뿐만 아니라, 사용자가 버튼을 클릭하거나 로그인 화면에서 아이디를 입력하는 동작이 모두 데이터 스트림이 될 수 있다. *반응형 프로그래밍*에서는 수 많은 데이터 스트림이 비동기적으로 동작하여, 데이터 스트림의 변화에 '반응(Reactive)'한다. 이때 데이터 스트림의 변화에 대해 반응하기 위해 *옵저버 패턴*을 기반으로 한다. 하나의 데이터 스트림의 변화가 발생하면, 해당 스트림을 구독하는 대상에게 전파되어 관련 작업을 한다. 

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183792966-9d147e5f-462c-4428-a8f1-8579147abe25.png" width="500">
</p>

&nbsp;
## 반응형 프로그래밍의 장점

이러한 *반응형 프로그래밍*의 매커니즘은 프론트엔드 관점에서 비동기적인 상황에 잘 대응할 수 있게 한다. 프론트엔드에서 서버와 통신은 대부분 비동기적인 코드로 작성한다. 이는 코드를 호출한 순서대로 동작한다는 보장이 없고, 호출할 당시의 데이터가 실제로 실행될 때 그대로일 거라는 보장도 없다. 

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183793957-e4f869cb-44f9-4ce2-9d25-0364f12b6832.png" width="500">
</p>

하지만 *반응형 프로그래밍*은 데이터 스트림과 이를 구독하는 대상의 로직이 유기적으로 연결되어 어려운 비동기적인 상황에 잘 대응할 수 있다. 이는 뷰가 뷰 모델의 변화를 스스로 알아차려서 로직을 수행하는 [MVVM](./mvvm.md)의 본질과 어울린다. 뷰 모델의 변화를 하나의 데이터 스트림으로 만들고 뷰가 스트림을 구독하면, 분리된 뷰와 뷰 모델을 유기적으로 동작시킬 수 있다.

또한 *반응형 프로그래밍*의 주체는 데이터의 변경을 알리는 쪽이 아닌, 데이터의 변경을 구독하고 이를 템플릿에 반영하는 쪽이다. 데이터의 변경을 알리는 쪽은 단순히 데이터가 변경될 때 전달만 한다. 이는 데이터의 변경을 알리는 쪽과 템플릿에 반영하는 쪽의 결합도를 낮추게 된다. 따라서 모듈간의 책임이 분명해져 캡슐화가 용이해지고, 확장이 쉬워진다.

&nbsp;
## 선언적 프로그래밍

마지막으로 *반응형 프로그램*의 정의를 살펴보면 '데이터 스트림과 그 변화에 대한 **선언적 프로그래밍** 패러다임이다.'라고 돼있다. 이를 해석해보면 데이터 스트림이 변화할 때, 이를 구독하고 있는 쪽에 전파하는 과정을 선언적으로 작성한다는 의미이다. 우리는 `for`가 아닌 `map`, `reduce`, `filter`와 같은 함수를 통해 코드를 선언적으로 작성할 수 있다. 예를 들어, 아래의 코드는 임의의 숫자 5개 중에서 짝수인 숫자 2개를 출력하는 선언적인 방식의 코드이다.

```swift
[1, 2, 3, 4, 5]
    .filter { $0 % 2 == 0 }
    .forEach { print($0) }
```

아래의 코드와 같이 *반응형 프로그래밍*에서는 데이터 스트림을 선언적으로 작성한다.

```swift
Observable.of([1, 2, 3, 4, 5])
    .filter { $0 % 2 == 0 }
    .forEach { print($0) }
```

&nbsp;
## ReactiveX

반응형 프로그래밍에 대해 찾다보면 *ReactiveX*가 따라다닌다. Swift의 *Combine*과 같이 프로그래밍 언어에 내장된 반응형 프로그래밍을 위한 API가 있지만, 아직까지 대부분의 소프트웨어는 반응형 프로그래밍을 위해 *ReactiveX*를 사용한다. [*ReactiveX*](https://github.com/reactivex)는 *Reactive Extensions*의 줄임말로, '**비동기 프로그래밍을 위한 반응형 Extensions**`이다. 이는 관측 가능한 스트림을 통해 비동기 프로그래밍을 하기 위한 API이다.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183795987-bd4531e9-a209-4083-a3c7-8e435895d19c.png" width="500">
</p>

### 함수형 프로그래밍

위 그림을 살펴보면 *ReactiveX*는 비동기적인 데이터 스트림과 관련된 *반응형 프로그래밍*과 함께 *함수형 프로그래밍*이 사용된다. *함수형 프로그래밍*은 [*선언형 프로그래밍*](./imperative-and-declarative-programming.md/#선언형-프로그래밍)에 속하는 프로그래밍 패러다임으로, 원본 값을 함수를 통해 전달해서 새로운 값을 만들어내는 조합이 다시 하나의 함수가 되는 구조이다. *함수형 프로그래밍*에 대해서는 [여기](./functional-programming.md)에 자세히 정리할 예정이다. 본 글에서는 *ReactiveX*에서 *함수형 프로그래밍*이 어떤 목적으로 사용되는지만 이해하자.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183813991-33e98d17-7ea6-42bb-b7d3-c239345afe96.png" width="500">
</p>

이러한 *함수형 프로그래밍*에서는 순수 함수를 조합하여 데이터를 처리하는데, 이는 *반응형 프로그래밍*과 어울린다. *반응형 프로그래밍*에서는 데이터 스트림 내부에서 데이터를 가공하여 전파하는데, 데이터를 가공하기 위한 Operator들은 필연적으로 순수 함수여야 한다. 이러한 *함수형 프로그래밍*은 *ReactiveX*에서 데이터 스트림을 중첩된 PipeLine을 통해서 생성할 수 있도록 도와준다.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/183816185-95ccc2d5-cc3a-414f-96b8-8fa7a6882e0f.png" width="500">
</p>

### 반복자(Iterator) 패턴

반복자 패턴은 비교적 간단하고 자주 사용되는 디자인 패턴이다. 모든 프로그래밍 언어에 있는 컬렉션은 해당 개체를 반복할 수 있는 반복자를 제공해야 한다. 그러나 개체를 반복하는 동안 구현이 노출되지 않도록 해야한다. 만약 애플리케이션에서 알림 목록을 유지 관리한다고 가정할 때, 결국 코드의 일부는 모든 알림을 순회해야 한다. 우리는 반복자 패턴을 통해 `Iterator`를 구현함으로써 유형에 관계없이 컬렉션을 순회할 수 있다.

```swift
let iterator: Iterator = notificationList.createIterator()

while iterator.hasNext() {
  let notification = iterator.next()
}
```

*ReactiveX*는 모든 시퀀스의 요소들을 반복자 패턴을 통해 순회한다. *ReactiveX*에서는 `Observable`의 이벤트를 방출할 때 반복자 패턴이 사용된다.

### Observable

본 글에서는 *ReactiveX*의 전반적인 개념에 대해서만 다룬다. 따라서 `Observable`은 반복자 패턴이 어떻게 사용되는지 설명하기 위해 내용을 추가했다. `Disposable`, `Subject` 등 *ReactiveX*에 대한 자세한 내용은 따로 정리할 예정이다. `Observable`은 관측 가능한 모든 요소를 나타내며, 시퀀스의 일종이다. 또한 데이터가 변경돼도 구독하고 있는 대상이 없다면 어떠한 이벤트도 방출하지 않는다. `Observable`이 방출하는 이벤트는 세 가지 종류가 있다.

- *Next* : 구독자에게 데이터를 전달한다. 이는 반복자 패턴의 `next()`와 같다.
- *Completed* : 구독자에게 이벤트가 완료됐음을 알린다. 이후 더 이상 이벤트를 방출하지 않는다.
- *Error* : 구독자에게 에러를 전달한다. 이후 더 이상 이벤트를 방출하지 않는다.

아래는 `Observable`을 구독하고 방출된 이벤트를 출력하는 코드이다.

```swift
let one = 1
let two = 2
let three = 3
let observable = Observable.of(one, two, three)
observable.subscribe { event in 
  print(event)
}
```
```
next(1)
next(2)
next(3)
completed
```

### ReactiveX를 써야하는 이유

*Swift*의 `NotificationCenter`, 프로퍼티 옵저버 등으로 반응형 프로그래밍을 구현할 수 있지만, *ReactiveX*는 스트림의 데이터를 변경시키는 수 많은 Operator를 제공한다. 또한 *ReactiveX*는 *Swift* 뿐만 아니라 *Java*, *Kotlin* 등 많은 프로그래밍 언어를 지원한다. 따라서 다른 플랫폼에서 *ReactiveX*를 사용하는 개발자와 대화할 수 있다. 아래는 [*RxSwift*](https://github.com/ReactiveX/RxSwift)에서 얘기하는 ReactiveX의 장점이다.

- 다양한 언어 지원
- 다양한 오퍼레이터를 통해 데이터 스트림을 쉽게 조합
- 복잡한 비동기 코드를 단순하고 직관적이게 작성
- 스케쥴러를 통해 간편하게 스레드 처리

