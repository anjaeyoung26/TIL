# 스케줄러

## 스케줄링 큐

프로세스를 스케줄링하기 위한 **Queue**에는 세 가지 종류가 있다.

- **Ready Queue** : 현재 메모리 내에 있으면서 CPU를 할당받기를 기다리는 프로세스의 집합
- **Job Queue** : 현재 시스템 내에 있는 모든 프로세스의 집합
- **Device Queue** : 입/출력 작업을 대기하는 프로세스의 집합

각각의 Queue에 프로세스를 추가하거나 빼주는 스케줄러는 세 가지 종류가 있다.

&nbsp;
## 장기 스케줄러

**Long-term** **스케줄러** 혹은 **Job** **스케줄러**라고 불리며 디스크에서 메모리를 할당하여 `Ready Queue`에 보낼 프로세스를 결정하여 메모리와 디스크 사이의 스케줄링 담당한다. 

한정된 메모리에 많은 프로세스가 한꺼번에 올라오려는 경우 대용량 메모리(디스크)에 임시로 저장된다. 이때 대용량 메모리에서 `Ready Queue`에 보낼 프로세스를 결정한다. 장기 스케줄러에 의해 `Ready Queue`에 보내진 프로세스의 상태는 `new` -> `ready`로 변경된다.

&nbsp;
## 단기 스케줄러

**Short-term** **스케줄러** 혹은 **CPU** **스케줄러**라고 불리며 메모리에 올라와있는 프로세스 중 어떤 프로세스를 CPU에 할당할 지 결정하여 CPU와 메모리 사이의 스케줄링 담당한다. 

장기 스케줄러가 `Ready Queue`에 보낸(메모리를 할당한) 프로세스 중 CPU를 할당할 프로세스를 결정한다. 단기 스케줄러에 의해 CPU를 할당받고 실행되는 프로세스의 상태는 `ready` -> `running` -> `waiting(block)` -> `ready`로 변경된다. 

&nbsp;
## 중기 스케줄러

**Medium-term** **스케줄러** 혹은 **Swapper** 라고 불리며 너무 많은 프로세스에게 메모리를 할당하여 시스템의 성능이 저하되는 경우 프로세스의 수를 동적으로 조절한다. 중기 스케줄러에 의해 정지되는 프로세스의 상태는 `ready` -> `suspended`로 변경된다.

> `suspended`는 외부적인 이유로 프로세스의 수행이 정지되어 메모리에서 내려간 상태를 의미한다. 다른 입/출력 작업을 기다리는 `blocked` 상태와 다르게 스스로 `ready` 상태로 돌아갈 수 없다.

장기 스케줄러와 마찬가지로 DOM 제어를 한다. 장기 스케줄러는 몇개의 프로세스를 메모리에 올릴지 결정한다면, 중기 스케줄러는 이미 메모리에 올라와있는 프로세스를 내려서 수를 조절한다. 이때 중기 스케줄러가 메모리 <-> 디스크 사이에서 프로세스를 이동시키는 동작을 `swap-in`, `swap-out`이라 한다.

&nbsp;
## 알고리즘

스케줄러의 알고리즘은 세 가지 목표를 가지고 있다. 스케줄러 알고리즘은 우선순위가 더 높은 프로세스가 추가될 때, 기존에 실행 중인 프로세스가 할당받은 CPU를 반납하는지 여부에 따라 비선점 스케줄링과 선점 스케줄링으로 나눌 수 있다.

- **No Starvation** : 각각의 프로세스들이 오랜 시간동안 CPU를 할당받지 못하면 안된다.
- **Fairness** : 각각의 프로세스에 공평하게 CPU를 할당한다.
- **Balance** : Keeping all parts of the system busy.

&nbsp;
### 비선점 스케줄링

프로세스가 종료되거나 자발적으로 중지될 때까지 실행을 보장한다.

1. **FCFS(First Come First Served)** : 자원을 요청한 프로세스 순서대로 할당한다. 만약 요구 시간이 긴 프로세스가 먼저 자원을 요청할 경우 호율성이 낮아지며 단기 스케줄링에 유리하다.

2. **SJF(Shortest Job First)** : CPU 점유 시간이 짧은 프로세스부터 할당한다. FCFS와 반대로 요구 시간이 긴 프로세스는 Starvation이 발생할 수 있으며 장기 스케줄링에 유리하다.

3. **HRRN(Highest Response Ratio Next)** : SJF 스케줄링을 보완한 것으로 프로세스의 대기 시간과 요구 시간을 함께 고려하여 할당

    > 우선순위 = (대기시간+요구시간) / 요구시간

&nbsp;
### 선점 스케줄링

다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 강제로 점유할 수 있다.

1. **RR(Round Robin)** : 각 프로세스가 동일한 크기의 할당 시간을 갖게되며 할당 시간이 지나면 프로세스의 정보(Context)를 저장한 뒤 `Ready Queue`의 제일 뒤에 가서 다시 줄을 선다. 응답 시간이 짧아 실시간 시스템에 유리하고 한 프로세스가 CPU를 독점하지 않는다. 하지만 할당 시간이 지나고 프로세스의 정보를 저장하는 Context Switching이 잦아 오버헤드가 발생하고 할당 시간이 너무 커지면 FCFS와 같아진다.
        
2. **SRT(Shortest Remaining time First)** : 선점형 SJF 스케줄링이라 불리며 진행 중인 프로세스가 있어도 잔여시간(Burst Time)이 더 짧은 프로세스를 선점한다. 새로운 프로세스가 도달할 때마다 스케줄링을 다시하므로 CPU 사용 시간을 측정할 수 없으며, 요구 시간이 긴 프로세스는 Starvation이 발생할 수 있다.
    
3. **Priority Scheduling** : 우선순위가 높은 프로세스부터 CPU를 할당한다. 우선순위는 제한 시간, 사용하는 파일의 수 등 내부적인 요소와 프로세스의 중요성, 정책적 요인 등 외부적인 요소에 따라 결졍된다. 만약 우선순위가 같은 프로세스들은 FCFS와 같이 동작하며 선점형, 비선점형 방식에서 모두 사용할 수 있다. 우선순위에 따라 Starvation과 Indefinite Blocking이 발생할 수 있다.

    > 무기한 봉쇄(Indefinite Blocking) : 실행 준비는 되어있으나 CPU를 사용하지 못하는 프로세스가 무기한 대기하는 상태