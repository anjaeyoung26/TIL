# 스케줄러

## 스케줄링 큐

프로세스를 스케줄링하기 위한 **Queue**에는 세 가지 종류가 있다.

- **Job Queue** : 현재 시스템 내에 있는 모든 프로세스의 집합
- **Ready Queue** : 현재 메모리 내에 있으면서 CPU를 할당받기를 기다리는 프로세스의 집합
- **Device Queue** : 입/출력 작업을 대기하는 프로세스의 집합

현재 실행 중인 프로세스에 입/출력 요청이 들어오면 프로세스는 CPU 점유권을 잃고 asleep 상태가 된다. 이때 Device Queue로 들어가며 입/출력 작업이 끝나면 다시 Ready Queue로 들어간다. 각각의 Queue에 프로세스를 추가하거나 빼주는 스케줄러는 세 가지 종류가 있다.

&nbsp;
## 장기 스케줄러

**Long-term** **스케줄러** 혹은 **Job** **스케줄러**라고 불리며 디스크에서 메모리를 할당하여 Ready Queue에 보낼 프로세스를 결정한다.

- **메모리와 디스크 사이의 스케줄링 담당** : 한정된 메모리에 많은 프로세스가 한꺼번에 올라오려는 경우 대용량 메모리(디스크)에 임시로 저장된다. 이때 대용량 메모리에서 Ready Queue에 보낼 프로세스를 결정한다.
- **DOM(Degree of Multiprogramming) 제어** : 메모리에 몇개의 프로세스가 올라갈 것인지 제어
- 장기 스케줄러에 의해 Ready Queue에 보내진 프로세스의 상태는 `new` -> `ready`로 변경된다.

&nbsp;
## 단기 스케줄러

**Short-term** **스케줄러** 혹은 **CPU** **스케줄러**라고 불리며 메모리에 올라와있는 프로세스 중 어떤 프로세스를 CPU에 할당할 지 결정한다. 

- **CPU와 메모리 사이의 스케줄링 담당** : 장기 스케줄러가 Ready Queue에 보낸(메모리를 할당한) 프로세스 중 CPU를 할당할 프로세스를 결정한다.
- 단기 스케줄러에 의해 CPU를 할당받고 실행되는 프로세스의 상태는 `ready` -> `running` -> `waiting(block)` -> `ready`로 변경된다. 

&nbsp;
## 중기 스케줄러

**Medium-term** **스케줄러** 혹은 **Swapper** 라고 불리며 너무 많은 프로세스에게 메모리를 할당하여 시스템의 성능이 저하되는 경우 프로세스의 수를 동적으로 조절한다.

- 중기 스케줄러에 의해 정지되는 프로세스의 상태는 `ready` -> `suspended`로 변경된다.

    - `suspended` : 외부적인 이유로 프로세스의 수행이 정지되어 메모리에서 내려간 상태를 의미한다. 다른 입/출력 작업을 기다리는 `blocked` 상태와 다르게 스스로 `ready` 상태로 돌아갈 수 없다.

장기 스케줄러와 마찬가지로 DOM 제어를 한다. 장기 스케줄러는 몇개의 프로세스를 메모리에 올릴지 결정한다면, 중기 스케줄러는 이미 메모리에 올라와있는 프로세스를 내려서 수를 조절한다. 이때 중기 스케줄러가 메모리 <-> 디스크 사이에서 프로세스를 이동시키는 동작을 `swap-in`, `swap-out`이라 한다.

- `swap-in` : 디스크로 내린 프로세스를 다시 메모리에 올린다.
- `swap-out` : 메모리에 있는 프로세스 중 우선순위가 낮은 프로세스를 디스크로 내린다.

&nbsp;
## 알고리즘

스케줄러의 알고리즘은 세 가지 목표를 가지고 있다. 스케줄러 알고리즘은 우선순위가 더 높은 프로세스가 추가될 때, 기존에 실행 중인 프로세스가 할당받은 CPU를 반납하는지 여부에 따라 비선점 스케줄링과 선점 스케줄링으로 나눌 수 있다.

- **No Starvation** : 각각의 프로세스들이 오랜 시간동안 CPU를 할당받지 못하면 안된다.
- **Fairness** : 각각의 프로세스에 공평하게 CPU를 할당한다.
- **Balance** : Keeping all parts of the system busy.

&nbsp;
### 비선점 스케줄링

프로세스가 종료되거나 자발적으로 중지될 때까지 실행을 보장한다.

1. **FCFS(First Come First Served)** : 자원을 요청한 프로세스 순서대로 할당
    - 요구 시간이 긴 프로세스가 먼저 자원을 요청할 경우 호율성이 낮아진다.
    - 단기 스케줄링에 유리하다.

2. **SJF(Shortest Job First)** : CPU 점유 시간이 짧은 프로세스부터 할당
    - 요구 시간이 긴 프로세스는 [Starvation](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A5%20b45146b6b3344b35b5a8fee514bc7b28.md)이 발생할 수 있다.
    - 장기 스케줄링에 유리하다.

3. **HRRN(Highest Response Ratio Next)** : SJF 스케줄링을 보완한 것으로 프로세스의 대기 시간과 요구 시간을 함께 고려하여 할당
    - 우선순위 = (대기시간+요구시간) / 요구시간

&nbsp;
### 선점 스케줄링

다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 강제로 점유할 수 있다.

1. **RR(Round Robin)** : 각 프로세스가 동일한 크기의 할당 시간(Time Quantum)을 갖게되며 할당 시간이 지나면 프로세스의 정보(Context)를 저장한 뒤 Ready Queue의 제일 뒤에 가서 다시 줄을 선다.
    
    <img src="https://user-images.githubusercontent.com/61190690/166911942-cafdf804-00e1-43d6-947e-3671beeffb85.png" width="400" height="200">
    
    - 장점
        1. 응답 시간이 짧아 실시간 시스템에 유리하다.
        2. 한 프로세스가 CPU를 독점하지 않는다.

    - 단점
        1. Context Switching가 잦아 오버헤드가 발생한다.
        2. 할당 시간이 너무 커지면 [FCFS](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A5%20b45146b6b3344b35b5a8fee514bc7b28.md)와 같아진다.
        
2. **SRT(Shortest Remaining time First)** : 선점형 SJF 스케줄링이라 불리며 진행 중인 프로세스가 있어도 잔여시간(Burst Time)이 더 짧은 프로세스를 선점한다.
    - 새로운 프로세스가 도달할 때마다 스케줄링을 다시하므로 CPU 사용시간을 측정할 수 없다.
    - [Starvation](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A5%20b45146b6b3344b35b5a8fee514bc7b28.md)이 발생할 수 있다.
    
3. **Priority Scheduling** : 우선순위가 높은 프로세스부터 CPU를 할당한다.
    - 우선순위가 같은 프로세스들은 [FCFS](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A5%20b45146b6b3344b35b5a8fee514bc7b28.md)
    - 선점형, 비선점형 방식을 모두 사용할 수 있다.
    - [Starvation](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A5%20b45146b6b3344b35b5a8fee514bc7b28.md)과 무기한 봉쇄(Indefinite Blocking)가 발생할 수 있다.
        - 무기한 봉쇄 : 실행 준비는 되어있으나 CPU를 사용하지 못하는 프로세스가 무기한 대기하는 상태