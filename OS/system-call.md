# System Call

운영체제는 커널 모드와 사용자 모드로 나뉘어 구동된다. 이때 커널 모드는 운영체제에서 프로그램이 구동될 때 파일을 읽고 쓰거나 화면에 메시지를 출력하는 등 많은 부분에서 사용한다. 시스템 콜은 응용 프로그램의 요청에 따라 사용자 모드에서 커널 모드의 서비스를 사용할 수 있또록 커널에 접근하기 위한 인터페이스이다. 일반적으로 C, C+과 같은 고급 언어로 작성된 프로그램들은 시스템 호출을 직접 사용할 수 없기 때문에 고급 API를 통해 접근한다.

&nbsp;

**시스템 콜이 필요한 이유?**

일반적으로 우리가 사용하는 프로그램은 '응용 프로그램'이다. 이러한 사용자 레벨의 프로그램은 사용자 레벨에서 사용할 수 있는 함수들 만으로 많은 기능을 구현할 수 없어 커널의 도움을 받아야 한다. 그러기 위해서는 사용자 모드에서 수행되는 유저 프로세스에서 수행할 수 없어 커널 모드로 전환해야 한다. 이와 같이 커널 모드를 통한 작업은 반드시 시스템 콜을 통해서 수행하도록 설계되어 있다.

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/171653610-0518e2eb-ea69-4564-bdfd-a6efefe753e5.png">
</p>

&nbsp;

**그렇다면 커널 모드에 접근하기 위한 권한은 왜 필요할까?**

이는 악의적인 의도로 접근하여 시스템 콜을 사용하거나 운영 체제에 대해 미숙한 사용자가 잘못된 명령어를 입력하는 것을 방지하기 위해 권한이 있는 사용자만 접근할 수 있도록 한다. 따라서 특정 명령어는 커널 모드에서만 실행할 수 있도록 설계되었고, 만약 사용자 모드에서 시스템 콜을 호출하는 경우에는 운영체제가 비정상적인 접근이라 판단하여 [Trap](./interrupt.md/#내부-인터럽트)을 발생시킨다.

&nbsp;
## 시스템 콜의 예시

```
cp in.txt out.txt
```

위 명령어를 통해 `in.txt` 파일의 내용을 복사하여 `out.txt` 파일을 생성한다. 이때 시스템 콜이 어떻게 사용되는지 살펴보자.

1. `in.txt` 파일이 현재 디렉토리에서 접근할 수 있는 파일인지 검사한다. 현재 디렉토리에 존재하지 않는 파일이라면 에러를 발생시키고 프로그램을 종료한다.

2. `in.txt` 파일을 찾으면, 복사한 파일을 저장하기 위해 `output.txt`과 동일한 이름을 가진 파일이 있는지 확인한다. 만약 파일 명이 이미 존재한다면 사용자에게 덮어 씌울지, 대체할지 물어본다.

3. `output.txt`와 동일한 이름의 파일이 없다면 파일을 저장한다.

1, 2, 3 과정에서 모두 시스템 콜을 사용한다. 텍스트 파일의 내용을 복사해서 새로운 파일을 생성하는 단순한 과정임에도 불구하고 많은 시스템 콜이 호출된다.

&nbsp;
## 시스템 콜의 종류

1. **프로세스 컨트롤**

    - 프로세스 생성 및 종료
    - 메모리에 로드 및 실행
    - 프로세스 속성 값 확인
    - 메모리 할당

2. **파일 관리**

    - 파일 생성 및 삭제
    - 파일 열기 및 닫기
    - 파일 읽기 및 쓰기
    - 파일 속성 값 확인

3. **디바이스 관리**

    - 디바이스 요청 및 해제
    - 디바이스 읽기 및 쓰기
    - 디바이스 속성 값 확인

4. **정보 관리**

    - 시간 확인 및 지정
    - 시스템 데이터 확인
    - 프로세스, 파일, 디바이스 속성 가져오기 및 설정

5. **통신**

    - 통신 연결 및 해제
    - 메시지의 송수신
    - 상태 정보 전달