# 인터럽트

<p align="center">
<img src="https://user-images.githubusercontent.com/61190690/171364561-86127caa-20db-425c-a74d-99e0cfbe9ae8.png" width="700">
</p>

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치와 커뮤니케이션 해야할 때나 예외 상황이 발생하면 CPU에게 알려서 처리할 수 있도록 한다. 이때 CPU가 실행하고 있는 프로그램에 대한 정보인 레지스터와 PC를 PCB에 저장하고, CPU의 제어를 ISR(Interrupt Service Routing)에 넘긴다. 그리고 인터럽트를 모두 처리하면 PCB에 저장해놓은 정보를 다시 가져와서 프로그램을 실행한다. 

### 인터럽트 처리 과정

인터럽트가 처리되는 과정을 간략하게 나타내면 아래와 같다. 만약 CPU가 인터럽트를 처리하고 있을 때 새로운 인터럽트가 들어온다면 각 인터럽트의 중요도에 따라 우선순위를 판단해서 처리한다.

1. 인터럽트가 발생한다.
2. 현재 수행 중인 프로세스의 정보를 PCB에 저장한다.
3. 프로그램 카운터에 다음에 수행할 명령의 주소를 저장한다.
4. ISR에서 인터럽트를 처리한다.
5. 프로그램 카운터의 값을 통해 인터럽트가 발생하기 전에 수행하던 프로세스를 수행한다.

&nbsp;
## 인터럽트의 필요성

### [선점형 스케줄러](./scheduler.md/#선점-스케줄링) 구현

선점형 스케줄러를 구현하기 위해서는 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행해야 하는데, 이때 타이머 인터럽트를 사용한다. 하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려주는 스케줄러 코드를 실행한다.

선점형 스케줄링에 사용하는 Round Robin 알고리즘을 살펴보자. 각 프로세스가 동일한 크기의 할당 시간을 갖게 되며, 할당 시간이 지나면 프로세스의 정보를 저장하고 Ready Queue의 제일 뒤에 줄을 세운다. 이때 인터럽트를 통해 실행 중인 프로세스는 `Ready` 상태가 된다.

&nbsp;
### 입출력 장치와 커뮤니케이션

마우스, 키보드, 프린터와 같은 입출력 장치에서 작업이 필요할 때, CPU가 입출력 관리자에게 입출력 명령을 보낸다. 입출력 관리자는 명령받은 작업을 처리하고 CPU에게 완료되었다는 신호를 보낸다. 이때 입출력 관리자가 CPU에게 보내는 완료 신호가 인터럽트이다. CPU는 완료 신호를 받으면 입출력 작업을 하기 전 실행 중이였던 `Block` 상태의 프로세스를 `Ready` 상태로 깨운다.

&nbsp;
### 예외 상황 처리

```c
int main() {
  int data;
  int divider = 0;
  data = 1 / divider;
  return 0;
}
```

위 코드에서 숫자 1을 0으로 나누려고 시도해 예외 상황이 발생한다. 이를 운영체제에 알려서 해당 프로세스를 중지시키고 에러를 표시한다.

```
Floating Point exceptino (core dumped)
```

&nbsp;
## 인터럽트의 종류

### 외부 인터럽트

외부 인터럽트란 CPU와 독립되어 있는 키보드, 마우스와 같은 입출력 장치나 전원 이상, 타이머 이벤트와 같은 **외부적인 요인으로 인해 발생되는 인터럽트**로 일반적으로 인터럽트라고 하면 대부분 외부 인터럽트를 지칭한다. 이제 외부 인터럽트의 종류에 대해 알아보자.

1. **전원 이상 인터럽트(Power Fail Interrupt)** : 정전, 파워 이상
2. **기계 착오 인터럽트(Machine Check Interrupt)** : CPU의 기능적인 오류
3. **입출력 인터럽트(I/O Interrupt)** : 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나고 다음 동작이 수행되어야 할 경우
4. **기타**
    - 외부 장치로부터 인터럽트 요청이 있는 경우
    - 키보드로 인터럽트 키를 누른 경우
    - 자원이 할당된 시간이 끝난 경우

&nbsp;
### 내부 인터럽트

내부 인터럽트란 프로그램 내부에서 잘못된 명령이나 데이터를 사용할 때 발생하는 예외 상황을 의미하며, Trap 이라고도 한다. 내부 인터럽트의 대표적인 예로 프로그램 검사 인터럽트(Program Check Interrupt)가 있다.

1. 프로그램에서 명령어를 잘못 사용한 경우
2. 숫자를 0으로 나누는 연산
3. 오버플로우/언더플로우
4. 기타 프로그램 예외

&nbsp;
### 소프트웨어 인터럽트

소프트웨어 인터럽트는 프로그램 처리 중 명령의 요청에 의해서 발생하며, 대표적인 예로 프로그램에서 감시 프로그램(SVC)를 호출하는 경우가 있다. SVC는 프로세서 명령어로 수행 시 문제가 발생하면 프로세서가 운영체제를 관리 감독하는 프로그램에게 제어권을 넘겨서 해결한다. 예를 들어 한글 프로그램을 종료하기 위해 종료 버튼을 클릭하면, 한글 프로그램에 대한 제어를 운영체제의 감시 프로그램으로 옮기는 SVC 인터럽트가 발생한다.

> 소프트웨어 인터럽트와 내부 인터럽트의 차이: ?

&nbsp;

### 우선순위

> 전원 이상 > 기계 착오 > 외부 신호 > 입출력 > 잘못된 명령어 사용 > 프로그램 검사 > SVC

일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높고, 내부 인터럽트 보다 외부 인터럽트가 우선 순위가 높다. 만약 여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별이 필요하다. 이제 우선순위를 판별하는 여러가지 방법에 대해 알아보자.

&nbsp;
## 우선순위 판별

### Polling

폴링은 **소프트웨어적인 판별 방법**으로, 사용자가 명령어를 사용해 입력 핀의 값을 계속해서 읽고 변화를 알아내는 방식으로, 인터럽트 요청에 대한 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트를 찾아 ISR을 수행한다. 이제 폴링의 특징에 대해 알아보자.

1. 많은 인터럽트가 있을 경우 하드웨어적인 방법에 비해 속도가 느리다.
2. 회로가 간단하고 융통성이 있으며, 별도의 하드웨어가 필요 없다.
3. 속도에 따라 등급을 부여한다.
4. 우선순위 변경이 쉽다.

&nbsp;
### Vectored Interrupt

Vectored Interrupt는 **하드웨어적인 판별 밥법**으로, 인터럽트를 요청할 수 있는 장치와 CPU 사이에 장치의 번호에 해당하는 버스를 직렬 혹은 병렬로 연결하고 인터럽트가 발생했을 때 장치의 번호를 CPU에게 알리는 방식이다. 이때 인터럽트 발생 시 처리해야 할 인터럽트 핸들러의 주소를 보관하고 있는 테이블을 **인터럽트 벡터**라고 한다. 이제 Vectored Interrupt의 특징에 대해 알아보자.

1. 회로가 복잡하고 융통성이 없으나, 별도의 소프트웨어가 필요없어 속도가 빠르다.
2. 추가적인 하드웨어가 필요하므로 비경제적이다.
3. 버스를 연결하는 방법에 따른 두 가지 종류가 있다.
    - **직렬 우선순위 부여 방식** : 인터럽트가 발생하는 모든 장치를 한 개의 회선에 직렬로 연결하고 우선순위에 따라 선두에 위치시킨다. 이를 **Daisy-Chain**라고도 한다.

    - **병렬 우선순위 부여 방식** : 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결하고 Mask Register의 비트 위치에 따라 우선순위를 결정한다. Mask Register는 우선순위가 높은 인터럽트의 서비스 루틴이 수행 중일 때 우선순위가 낮은 bit를 비활성화 시킬 수 있다. 반대로 우선순위가 높은 인터럽트는 낮은 인터럽트의 서비스 루틴이 수행될 때에도 우선적으로 처리된다.

