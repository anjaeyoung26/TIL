# Deadlock

<img src="https://user-images.githubusercontent.com/61190690/168003685-743924ac-afab-4c3c-89ab-41c0db2f3461.png" width="500">

두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태로 교착 상태라고도 한다.

&nbsp;
## 발생 조건

1. 상호 배제 : 한 번에 하나의 프로세스만 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 자원이 해제될 때까지 기다린다.

2. 점유 대기 : 최소한 하나의 자원을 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

3. 비선점 : 이미 할당된 자원을 강제로 뺏을 수 없다.

4. 순환 대기 : 대기 프로세스의 집합이 순환 형태여야 한다.

&nbsp;
## 해결 방법

해결 방법은 예방, 회피, 탐지 & 회복, 무시 총 4가지가 있다. 하나씩 살펴보자.

&nbsp;
### 예방
교착 상태의 발생 조건 4가지 중 하나라도 발생하지 않게 예방한다.

- 자원의 상호 배제 방지 : 한 번에 여러 프로세스가 자원을 사용할 수 있게 한다. 하지만 [Race Condition](../OS/process-synchronization.md/#race-condition)과 같은 동기화 문제를 야기할 수 있다.

- 점유 대기 방지 : 프로세스 실행에 필요한 모든 자원을 한 번에 요구하고 허용될 때까지 작업을 보류한다. 혹은 프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 한다. 추후 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.

- 비선점 방지 : 높은 우선순위의 프로세스가 이미 할당된 자원을 선점할 수 있도록 한다.

- 순환 대기 방지 : 순환 형태가 아닌 선형 형태로 대기하도록 한다.

교착 상태가 발생하지 않도록 차단할 수 있지만 동기화와 관련된 문제가 발생할 수 있고 시스템의 효율성이 낮아지는 문제가 있다. 그러므로 '교착 상태의 예방'보다는 덜 제한적인 '교착 상태의 회피' 방법을 통해 일부 문제를 해결한다.

&nbsp;
### 회피

<img src="https://user-images.githubusercontent.com/61190690/168014071-18852989-822d-4a10-a5aa-80e95fc30618.png" width="500">

시스템의 프로세스들이 요청하는 모든 자원을 교착 상태가 발생하지 않는 범위 내에서 할당할 수 있는 안정 상태를 유지한다. 만약 교착 상태가 발생할 수 있는 범위라면 다른 프로세스들이 자원을 해제할 때가지 대기시킨다. 안정 상태와 불안정 상태는 현재 할당된 자원의 수에 따라 나뉘어지며, 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 하고 시스템의 전체 자원 수가 고정적이여야 한다는 문제가 있다.

교착 상태와 관련된 알고리즘으로 **은행원 알고리즘**이 있다. 은행원 알고리즘은 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래했으며, 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태가 유지되는지 사전에 검사하여 교착 상태를 회피한다.

&nbsp;
### 탐지 & 회복

교착 상태가 되도록 허용한 뒤 회복시키는 방법이다.

- 탐지 기법 : 자원 할당 그래프를 통해 교착 상태를 탐지한다. 프로세스가 자원을 요청할 때마다 탐지 알고리즘을 실행시켜 오버헤드가 발생한다.

    <img src="https://user-images.githubusercontent.com/61190690/168010069-ff2a99f3-b382-4a09-b639-60188c366990.png" width="250">

    프로세스 P1로부터 자원 R1로의 방향에 대한 간선은 P1 -> R1로 표현하며 이것은 프로세스 P1가 자원 R1를 요청하고 기다리는 상태이다. 자원 R1로부터 프로세스 P1로의 방향에 대한 간선은 R1 -> P1로 표현하며 이것은 자원 R1가 프로세스 P1에 할당된 상태이다.

    어떻게 교착 상태가 발생했는지 탐지할까? 자원 할당 그래프에서 사이클이 존재한다면 교착 상태가 발생했다는 의미이다. 하지만 사이클이 존재한다고 무조건 교착 상태가 발생한 것은 아니다. 아래의 예시를 보자.

    - 교착 상태가 발생한 그래프

        <img src="https://user-images.githubusercontent.com/61190690/168010081-a13eb4a6-cb11-4280-8594-14a4939ce019.png" width="250">

    - 사이클은 있지만 교착 상태가 아닌 그래프

        <img src="https://user-images.githubusercontent.com/61190690/168010092-e5d92bdc-ba08-4af6-b5c9-7b8b000ed8a3.png" width="250">

        P4이 작업을 완료하고 R2를 반환하면 사이클 안에 있는 P1는 P4이 반환한 자원을 할당받는다.

- 회복 기법 : 교착 상태를 일으킨 프로세스를 종료시키거나 할당된 자원을 해제시킨다.

    - 프로세스 종료 방법 : 교착 상태의 프로세스를 모두 중지하거나 교착 상태가 제거될 때까지 하나씩 프로세스를 중지한다.

    - 자원 선점 방법 : 교착 상태의 프로세스가 점유하고 있는 자원을 선점해서 일시정지 시키고 다른 프로세스에게 자원을 할당한다. 우선 순위가 낮거나 수행 횟수가 적은 프로세스를 위주로 자원을 선점한다.

&nbsp;
### 무시

교착 상태의 예방, 회피, 탐지 & 복구하는 방법도 [Context Switching](./process-thread.md/#멀티-쓰레딩)에 의한 오버헤드로 성능 저하가 발생한다. 교착 상태에 의한 성능 저하보다 이를 해결할 때의 성능 저하가 더 큰 경우 교착 상태를 무시한다.

    
