# 메모리 관리 전략

## 배경

성능을 향상시키기 위해 하나의 프로세스가 아닌 **여러 개의 프로세스를 사용**하면서 메모리 관리의 중요성이 대두되었다.

- **적절한 메모리 위치에 프로그램을 적재하지 못할 경우 발생하는 문제를 방지**하고자 운영체제가 메모리를 관리한다.

- 왜 운영체제가? 각각의 프로세스는 독립된 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없다. 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역에 접근할 수 있다.

&nbsp;
## 효과적인 메모리 사용 기법

- **동적 적재** : 프로세스 전체가 아닌 실행에 반드시 필요한 루틴(예: 오류처리)과 데이터(예: 배열)만 적재하는 기법이다.

- **동적 연결** : 라이브러리 루틴을 컴파일 시점이 아닌 실행 시점에 연결하는 기법이다. `print()`와 같이 대부분의 프로그램에서 사용하는 라이브러리 루틴들을 중복해서 메모리에 올리지 않고 하나의 라이브러리 루틴만 메모리에 올린다.

- **Swapping** : 메모리에 적재되어 있으나 현재 사용되지 않는 프로세스를 하드 디스크의 Backing Store에 보내고, 필요할 때 다시 메모리에 올린다.

    - `swap-out` : 주 기억장치(RAM) → 보조 기억장치(하드 디스크)
    - `swap-in` : 보조 기억장치(하드 디스크) → 주 기억장치(RAM)

&nbsp;
## 단편화

Fragmentation, 프로세스들이 메모리에 적재, 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 사이에 사용하지 못하는 작은 공간이 늘어나는데 이를 단편화라고 한다.

### 외부 단편화

가변 분할 방식에서 여유 공간이 충분함에도 불구하고 조각으로 흩어져 있어 메모리에 프로세스가 적재되지 못해 메모리가 낭비되는 현상이다. 외부 단편화를 해결하기 위한 방법으로 압축과 페이징이 있다.

- **압축** : Compaction, 외부 단편화를 해결하기 위해 프로세스가 사용하는 공간들을 한 쪽으로 몰아 공간을 확보하는 방법론

- **페이징** : 압축의 오버헤드와 비효율적인 성능을 해소하기 위한 방식으로 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재한다. 논리 메모리를 같은 크기의 블록으로 나눈 것을 페이지(Page)라고 하고, 물리 메모리를 페이지와 같은 크기로 나눈 것을 프레임(Frame)이라고 한다. 페이징은 사용하지 않는 프레임을 페이지에 옮기고(swap-out), 필요한 메모리를 페이지 단위로 프레임에 옮기는(swap-in) 기법이다.

    - 내부 단편화가 발생할 수 있다 : 페이지의 크기가 1,024 Bytes 이고, 프로세스가 3,127 Bytes의 메모리가 필요하다면 3개의 프레임을 사용하고도 고작 100 Bytes 때문에 하나의 프레임이 더 필요하다.

    - 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없앤다. 남는 프레임에 적절히 배치되면서 외부 단편화를 해결한다.

&nbsp;
### 내부 단편화

고정 분할 방식에서 프로세스가 실제 사용해야할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상이다. 내부 단편화를 해결하는 방법으로 Segmentation이 있다.

- **Segmentation** : 페이징과 다르게 물리 메모리를 가변 크기로 나눈다.

    - 외부 단편화가 발생할 수 있다.

    - 프로세스를 `code`, `data`, `stack`으로 나누는 것도 Segmentation이다.

    - CPU에서 세그먼트의 크기보다 큰 주소가 들어오면 인터럽트가 발생해서 프로세스가 종료된다.

&nbsp;
## 가상 메모리

멀티 프로세스 환경에서는 보다 좋은 성능을 위해서 다수의 프로세스를 주기억장치에 올려놓아야 한다.(프로세스는 주기억장치에 올라가서 CPU를 할당받아야 실행할 수 있다.) 하지만 여러 프로그램을 메모리에 올리기에는 주기억장치 용량의 한계와 페이지 교체 등 문제가 발생한다. 이를 해결하고자 가상 메모리가 개발되었다.

- 한 프로그램이 실행되며 논리 메모리로 100 KB가 요구되었지만 실행까지 필요한 메모리 공간(Stack, Heap, Data, Text)의 합이 40 KB라면 물리 메모리에는 실제로 40 KB 만큼 올라가고, 나머지 60 KB 만큼은 필요 시에 물리 메모리에 요구한다.

가상 메모리는 프로세스를 실행할 때  필요한 부분만 메모리에 올리는 것으로 프로세스는 [가상 주소](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8%20f3637104716f4e27b0208263406abcff.md)를 사용하고, 실제 해당 주소에서 데이터를 Read/Write 할 때만 [물리 주소](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8%20f3637104716f4e27b0208263406abcff.md)로 바꿔서 사용한다.

- **논리 주소** : CPU가 프로세스를 실행할 때 실제 메모리 위치에 접근하기 위해 생성하는 주소로, 물리적으로 존재하지 않아서 **가상 주소**라고도 한다. 프로세스가 메모리에 적재되면 생기는 프로세스의 독자적인 주소 공간으로 0번지 부터 시작한다.

- **물리 주소** : CPU가 프로세스를 실행하는 실제 메모리의 위치이며 **실제 주소**라고도 한다. 사용자는 실제로 실제 주소를 다루지 않으며, 대신 논리 주소를 통해 접근한다.

- **MMU(Memory Management Unit)** : CPU가 프로그램을 실행할 때 가상 주소(논리 주소)를 물리 주소로 바꾸는(Mapping) 역할을 한다.

    <img src="https://user-images.githubusercontent.com/61190690/166915945-31665c82-055b-4f51-972d-f7db3f788863.png" width="500">