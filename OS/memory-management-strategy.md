# 메모리 관리 전략

## 배경

성능을 향상시키기 위해 하나의 프로세스가 아닌 **여러 개의 프로세스를 사용**하면서 메모리 관리의 중요성이 대두되었다. **적절한 메모리 위치에 프로그램을 적재하지 못할 경우 발생하는 문제를 방지**하고자 운영체제가 메모리를 관리한다.

> 왜 운영체제가? 각각의 프로세스는 독립된 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없다. 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역에 접근할 수 있다.

&nbsp;
## 효과적인 메모리 사용 기법

### 동적 적재

우리가 프로그램을 구현하면서 작성한 코드 중에서 모든 루틴과 데이터가 사용되지 않는다. 예외의 상황을 처리하는 경우 실행되는 코드와 반대로 예외가 발생하지 않을 때 실행되는 코드가 있다. 만약 모든 코드를 메모리에 적재할 경우 메모리의 낭비가 발생하기 때문에 프로세스 전체가 아닌 실행에 반드시 필요한 루틴과 데이터만 적재하는 기법이다. 가상 메모리가 개발되고 부터 필요하지 않게 되었다.

### 동적 연결

우선 동적 연결과 비교되는 정적 연결이 어떻게 이루어지는지 그림으로 알아보자:

<img src="https://user-images.githubusercontent.com/61190690/168693065-9201fc7b-04e9-4677-921b-e4402847796c.png" width="500">   

정적 연결은 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리의 모듈을 복사한다. 즉 어떤 프로그램에서 A라는 외부 함수를 사용했다면, A라는 외부 함수에 대한 정보를 자신이 작성한 프로그램의 실행 파일을 만들 때 복사해온다. 만약 여러 프로그램에서 A라는 외부 함수를 이용하면 중복이 발생한다. 그럼에도 불구하고 정적 연결 방식을 사용하는 이유는 뭘까?

1. 미리 컴파일 되어 있기 때문에 컴파일 시간이 단축된다.
2. 직접 구현한 코드를 라이브러리화 시켜 기술의 유출을 방지할 수 있다.

정적 연결의 메모리 낭비를 줄여 메모리를 효율적으로 사용할 수 있는 동적 연결 기법이 있다. 아래는 동적 연결에 대한 그림이다:

<img src="https://user-images.githubusercontent.com/61190690/168693070-e97ea4e0-3a41-4cd6-b712-aa8df8cc0bac.png" width="500">   

동적 연결은 라이브러리 루틴을 컴파일 시점이 아닌 실행 시점에 연결하는 기법이다. `print()`와 같이 대부분의 프로그램에서 사용하는 라이브러리 루틴들을 중복해서 메모리에 올리지 않고 하나의 라이브러리 루틴만 메모리에 올린다. 

### Swapping

<img src="https://user-images.githubusercontent.com/61190690/168696724-216bf502-766b-4d90-8b93-15af4b22e25c.png" width="500">

메모리에 적재되어 있으나 현재 사용되지 않는 프로세스를 하드 디스크의 Backing Store에 보내고(`swap-out`), 필요할 때 다시 메모리에 올린다(`swap-in`). Swapping은 메모리를 효율적으로 사용할 수 있으나 프로세스의 크기가 크다면 운여체제와 Backing Store 사이의 입출력에 따른 부담이 크다.

> `swap-out` : 주 기억장치(RAM) → 보조 기억장치(하드 디스크)   
> `swap-in` : 보조 기억장치(하드 디스크) → 주 기억장치(RAM)

&nbsp;
## 단편화

Fragmentation, 프로세스들이 메모리에 적재, 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 사이에 사용하지 못하는 작은 공간이 늘어나는데 이를 단편화라고 한다.

## 외부 단편화

가변 분할 방식에서 여유 공간이 충분함에도 불구하고 조각으로 흩어져 있어 메모리에 프로세스가 적재되지 못해 메모리가 낭비되는 현상이다. 외부 단편화를 해결하기 위한 방법으로 압축과 페이징이 있다.

### 압축

외부 단편화를 해결하기 위해 프로세스가 사용하는 공간들을 한 쪽으로 몰아 공간을 확보하는 기법이다.

### 페이징

압축의 오버헤드와 비효율적인 성능을 해소하기 위한 방식으로 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재한다. 논리 메모리를 같은 크기의 블록으로 나눈 것을 `페이지(Page)`라고 하고, 물리 메모리를 페이지와 같은 크기로 나눈 것을 `프레임(Frame)`이라고 한다. 페이징은 사용하지 않는 프레임을 페이지에 옮기고(swap-out), 필요한 메모리를 페이지 단위로 프레임에 옮기는(swap-in) 기법이다. 

페이징은 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없앤다. 남는 프레임에 적절히 배치되면서 외부 단편화를 해결한다. 하지만 페이지의 크기가 1,024 Bytes 이고, 프로세스가 3,127 Bytes의 메모리가 필요하다면 3개의 프레임을 사용하고도 고작 100 Bytes 때문에 하나의 프레임이 더 필요하기 때문에 **내부 단편화가 발생할 수 있다.**

&nbsp;
## 내부 단편화

고정 분할 방식에서 프로세스가 실제 사용해야할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상이다. 내부 단편화를 해결하는 방법으로 Segmentation이 있다.

### Segmentation

페이징과 다르게 물리 메모리를 가변 크기로 나눈다. 프로세스를 `code`, `data`, `stack`으로 나누는 것도 세그멘테이션의 일종이다. 프로세스가 필요한 메모리만큼 할당하기 때문에 내부 단편화를 해결할 수 있다. 하지만 CPU에서 세그먼트의 크기보다 큰 주소가 들어오면 인터럽트가 발생하여 프로세스가 종료되어 **외부 단편화가 발생할 수 있다.**

&nbsp;
## 가상 메모리

멀티 프로세스 환경에서는 보다 좋은 성능을 위해서 다수의 프로세스를 주기억장치에 올려놓아야 한다.(프로세스는 주기억장치에 올라가서 CPU를 할당받아야 실행할 수 있다.) 하지만 여러 프로그램을 메모리에 올리기에는 주기억장치 용량의 한계와 페이지 교체 등 문제가 발생한다. 이를 해결하고자 가상 메모리가 개발되었다.

> 한 프로그램이 실행되며 논리 메모리로 100 KB가 요구되었지만 실행까지 필요한 메모리 공간(Stack, Heap, Data, Text)의 합이 40 KB라면 물리 메모리에는 실제로 40 KB 만큼 올라가고, 나머지 60 KB 만큼은 필요 시에 물리 메모리에 요구한다.

### 왜 '가상' 메모리일까?

가상 메모리는 프로세스를 실행할 때  필요한 부분만 메모리에 올리는 것으로 프로세스는 [가상 주소](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8%20f3637104716f4e27b0208263406abcff.md)를 사용하고, 실제 해당 주소에서 데이터를 Read/Write 할 때만 [물리 주소](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8%20f3637104716f4e27b0208263406abcff.md)로 바꿔서 사용한다.

- **논리 주소** : CPU가 프로세스를 실행할 때 실제 메모리 위치에 접근하기 위해 생성하는 주소로, 물리적으로 존재하지 않아서 **가상 주소**라고도 한다. 프로세스가 메모리에 적재되면 생기는 프로세스의 독자적인 주소 공간으로 0번지 부터 시작한다.

- **물리 주소** : CPU가 프로세스를 실행하는 실제 메모리의 위치이며 **실제 주소**라고도 한다. 사용자는 실제로 실제 주소를 다루지 않으며, 대신 논리 주소를 통해 접근한다.

- **MMU(Memory Management Unit)** : CPU가 프로그램을 실행할 때 가상 주소(논리 주소)를 물리 주소로 바꾸는(Mapping) 역할을 한다.

    <img src="https://user-images.githubusercontent.com/61190690/166915945-31665c82-055b-4f51-972d-f7db3f788863.png" width="500">